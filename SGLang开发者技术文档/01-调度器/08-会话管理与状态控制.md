# 会话管理与状态控制

---

SGLang调度器支持会话级别的请求管理，通过Session机制实现对话上下文的持久化和请求链的管理。本章基于真实源码解析会话管理的核心实现。

---

## 🏗️ 会话架构设计

### 🎯 核心设计概念

**会话管理的设计理念**：Session类采用树形结构管理会话中的请求链，支持多轮对话的上下文保持和请求关系管理，通过容量控制确保内存使用的合理性。

> 📝 **简化说明**：以下为Session类的核心概念简化版本，突出主要设计思路。真实实现包含更多会话状态管理和错误处理逻辑。

```python
class Session:
    """会话管理（简化版）"""
    def __init__(self, capacity_of_str_len: int, session_id: str = None):
        self.session_id = session_id or uuid.uuid4().hex
        self.capacity_of_str_len = capacity_of_str_len  # 容量限制
        self.req_nodes: Dict[str, SessionReqNode] = {}  # 请求节点映射
        
    def create_req(self, recv_req, tokenizer):
        """创建会话请求（简化版）"""
        # 1. 构建请求对象
        # 2. 创建请求节点
        # 3. 建立父子关系
        pass
```

### 🔍 源码实现细节

```python
class Session:
    """真实的SGLang Session实现"""
    def __init__(self, capacity_of_str_len: int, session_id: Optional[str] = None):
        self.session_id = session_id if session_id is not None else uuid.uuid4().hex
        self.capacity_of_str_len = capacity_of_str_len  # 会话字符串长度容量限制
        self.req_nodes: Dict[str, SessionReqNode] = {}  # 请求ID到节点的映射

💡 **实现说明**: 真实的Session类支持会话容量管理、请求树结构、上下文保持等复杂功能。教学版本突出"ID管理→节点映射→容量控制"的核心架构。
```

### 📊 Session核心数据结构

### 🌳 SessionReqNode请求节点

```python
class SessionReqNode:
    def __init__(self, req, parent=None, childs=None):
        self.req = req                    # 关联的Req对象
        self.parent = parent              # 父节点引用
        self.childs = [] if not childs else childs  # 子节点列表
        
        # 自动建立父子关系
        if parent is not None:
            parent.childs.append(self)
```

请求节点构建了会话内的请求树结构，每个节点代表一个请求，通过parent/childs建立层次关系。

---

## 🔄 会话生命周期管理

### 🚀 会话创建流程

调度器通过`open_session`方法创建新会话：

```python
def open_session(self, recv_req: OpenSessionReqInput):
    """创建新会话"""
    session_id = recv_req.session_id
    
    # 1. 验证会话ID唯一性
    if session_id in self.sessions:
        logger.warning(f"session id {session_id} already exist, cannot open.")
        return OpenSessionReqOutput(session_id, False)
    elif session_id is None:
        logger.warning("session id is None, cannot open.")
        return OpenSessionReqOutput(session_id, False)
    
    # 2. 创建会话对象
    self.sessions[session_id] = Session(
        recv_req.capacity_of_str_len, session_id
    )
    
    return OpenSessionReqOutput(session_id, True)
```

### 🗑️ 会话销毁流程

```python
def close_session(self, recv_req: CloseSessionReqInput):
    """关闭并清理会话"""
    session_id = recv_req.session_id
    
    if session_id not in self.sessions:
        logger.warning(f"session id {session_id} does not exist, cannot delete.")
    else:
        # 简单地从sessions字典中删除
        del self.sessions[session_id]
```

---

## 🌳 请求树管理

### 🎯 会话请求创建

Session的核心方法是`create_req`，负责在会话中创建新请求并建立请求树结构：

```python
def create_req(self, req: TokenizedGenerateReqInput, tokenizer):
    """在会话中创建请求，构建请求树结构"""
    assert req.session_params is not None
    session_params = req.session_params
    
    last_req_node = None
    last_req = None
    abort = False
    
    # 1. 处理替换模式
    if session_params.replace:
        if session_params.rid is None:
            # 清空整个会话
            for _, req_node in self.req_nodes.items():
                req_node.clear(self.req_nodes)
        else:
            # 替换特定节点
            if session_params.rid not in self.req_nodes:
                abort = True
            else:
                last_req_node = self.req_nodes[session_params.rid]
                last_req_node.abort()
                last_req = last_req_node.req
                last_req_node.clear_childs(self.req_nodes)
    
    # 2. 处理追加模式
    else:
        if session_params.rid is not None:
            if session_params.rid not in self.req_nodes:
                abort = True
            else:
                last_req_node = self.req_nodes[session_params.rid]
                last_req = last_req_node.req
                if not last_req.finished():
                    logging.warning("向未完成的请求追加内容")
                    abort = True
    
    # 3. 构建输入序列（上下文继承）
    if last_req is not None:
        # 处理BOS token
        if tokenizer is not None and req.input_ids[0] == tokenizer.bos_token_id:
            req.input_ids = req.input_ids[1:]
        
        # 继承父请求的输入和输出
        input_ids = (
            last_req.origin_input_ids
            + last_req.output_ids[:last_req.sampling_params.max_new_tokens]
        )
        
        # 根据session_params调整继承行为
        if session_params.drop_previous_output:
            input_ids = last_req.origin_input_ids[:]
        
        if session_params.offset and session_params.offset != 0:
            input_ids = input_ids[:session_params.offset] + req.input_ids
        else:
            input_ids += req.input_ids
            
        # 同样处理unpadded版本
        input_ids_unpadded = (
            last_req.origin_input_ids_unpadded
            + last_req.output_ids[:last_req.sampling_params.max_new_tokens]
        )
        # ... 类似的处理逻辑
    else:
        input_ids = req.input_ids
        input_ids_unpadded = req.input_ids
    
    # 4. 创建新的Req对象
    new_req = Req(
        rid=req.rid,
        origin_input_text=None,
        origin_input_ids=input_ids,
        origin_input_ids_unpadded=input_ids_unpadded,
        sampling_params=req.sampling_params,
        lora_path=req.lora_path,
        session_id=self.session_id,
        custom_logit_processor=req.custom_logit_processor,
        stream=req.stream,
        return_logprob=req.return_logprob,
        top_logprobs_num=req.top_logprobs_num,
        token_ids_logprob=req.token_ids_logprob,
    )
    
    # 5. 继承多模态输入
    if last_req is not None:
        new_req.multimodal_inputs = last_req.multimodal_inputs
    new_req.tokenizer = tokenizer
    
    # 6. 处理abort情况或创建节点
    if abort:
        new_req.set_finish_with_abort("Invalid request session id")
    else:
        new_req_node = SessionReqNode(new_req, last_req_node)
        self.req_nodes[req.rid] = new_req_node
    
    return new_req
```

## 节点管理方法

### 清理子节点

```python
def clear_childs(self, req_dict):
    """递归清理所有子节点"""
    for req_node in self.childs:
        req_node.clear(req_dict)
    self.childs = []
```

### 清理节点

```python
def clear(self, req_dict):
    """清理当前节点及其所有子节点"""
    # 先递归清理子节点
    for req_node in self.childs:
        req_node.clear(req_dict)
    
    # 如果请求未完成，标记为终止
    if self.req.finished_reason is None:
        self.req.to_abort = True
    
    # 从请求字典中删除
    del req_dict[self.req.rid]
```

### 终止节点

```python
def abort(self):
    """终止节点对应的请求"""
    if self.req.finished_reason is None:
        self.req.to_abort = True
```

## 会话参数控制

### SessionParams配置

会话行为通过SessionParams控制：

```python
@dataclass
class SessionParams:
    id: Optional[str] = None              # 会话ID
    rid: Optional[str] = None             # 父请求ID
    offset: Optional[int] = None          # 继承偏移位置
    replace: Optional[bool] = None        # 是否替换模式
    drop_previous_output: Optional[bool] = None  # 是否丢弃前次输出
```

### 继承行为控制

- **正常追加**: 继承父请求的完整输入和输出
- **drop_previous_output**: 只继承输入，丢弃输出
- **offset**: 从指定位置开始继承
- **replace**: 替换指定节点而非追加

## API集成

### TokenizerManager中的会话管理

```python
async def open_session(self, obj: OpenSessionReqInput, request: Optional[fastapi.Request] = None):
    self.auto_create_handle_loop()
    
    # 生成会话ID（如果未提供）
    if obj.session_id is None:
        obj.session_id = uuid.uuid4().hex
    elif obj.session_id in self.session_futures:
        return None  # 会话已存在
    
    # 发送给调度器
    self.send_to_scheduler.send_pyobj(obj)
    
    # 等待调度器响应
    self.session_futures[obj.session_id] = asyncio.Future()
    session_id = await self.session_futures[obj.session_id]
    del self.session_futures[obj.session_id]
    return session_id

async def close_session(self, obj: CloseSessionReqInput, request: Optional[fastapi.Request] = None):
    await self.send_to_scheduler.send_pyobj(obj)
```

## 会话状态可视化

### 请求树打印

SessionReqNode提供了请求树的可视化方法：

```python
def __str__(self):
    return self._str_helper(self.req.rid)

def _str_helper(self, prefix=""):
    """递归构建树状结构字符串"""
    if len(self.childs) == 0:
        return prefix + "\n"
    else:
        origin_prefix = prefix
        prefix += " -- " + self.childs[0].req.rid
        ret = self.childs[0]._str_helper(prefix)
        for child in self.childs[1:]:
            prefix = " " * len(origin_prefix) + " \\- " + child.req.rid
            ret += child._str_helper(prefix)
        return ret
```

这会生成类似的树状输出：
```
root_request
 -- child1
    -- grandchild1
 \- child2
    -- grandchild2
    \- grandchild3
```

## 总结

SGLang的会话管理系统实际上相当简洁，核心功能包括：

**核心特性**: 
- 基于请求树的会话结构管理
- 自动的上下文继承机制
- 灵活的节点替换和追加模式
- 简单但有效的节点清理机制

**关键实现**:
- Session类管理会话元数据和请求节点映射
- SessionReqNode构建父子关系的请求树
- create_req方法实现复杂的上下文继承逻辑
- 调度器集成提供会话的创建和销毁接口

**设计哲学**: SGLang的会话管理采用了简单直接的设计，避免了过度复杂的状态管理，专注于核心的对话上下文继承功能。