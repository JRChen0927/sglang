# å†…å­˜å’Œèµ„æºç®¡ç†

---

SGLangè°ƒåº¦å™¨çš„å†…å­˜å’Œèµ„æºç®¡ç†é€šè¿‡å†…å­˜æ± ã€KVç¼“å­˜åˆ†é…å™¨å’Œå‰ç¼€ç¼“å­˜æœºåˆ¶æ¥å®ç°é«˜æ•ˆçš„GPUå†…å­˜åˆ©ç”¨ã€‚

---

## ğŸš€ å†…å­˜æ± åˆå§‹åŒ–

è°ƒåº¦å™¨é€šè¿‡`init_memory_pool_and_cache()`æ–¹æ³•åˆå§‹åŒ–å†…å­˜ç®¡ç†ç»„ä»¶ï¼š

```python
def init_memory_pool_and_cache(self):
    server_args = self.server_args

    # ä»tensor parallel workerè·å–å†…å­˜æ± 
    self.req_to_token_pool, self.token_to_kv_pool_allocator = (
        self.tp_worker.get_memory_pool()
    )

    # æ ¹æ®é…ç½®é€‰æ‹©ç¼“å­˜å®ç°
    if (server_args.chunked_prefill_size is not None 
        and server_args.disable_radix_cache):
        if self.is_hybrid:
            ChunkCacheClass = SWAChunkCache
        else:
            ChunkCacheClass = ChunkCache
        self.tree_cache = ChunkCacheClass(
            req_to_token_pool=self.req_to_token_pool,
            token_to_kv_pool_allocator=self.token_to_kv_pool_allocator,
            page_size=self.page_size,
        )
    else:
        # å®éªŒæ€§çš„C++å®ç°RadixCache
        if os.environ.get("SGLANG_EXPERIMENTAL_CPP_RADIX_TREE") == "1":
            from sglang.srt.mem_cache.radix_cache_cpp import RadixCacheCpp
            self.tree_cache = RadixCacheCpp(
                disable=False,
                use_hicache=self.enable_hierarchical_cache,
                req_to_token_pool=self.req_to_token_pool,
                token_to_kv_pool=self.token_to_kv_pool_allocator,
                tp_cache_group=self.tp_cpu_group,
                page_size=self.page_size,
                hicache_ratio=server_args.hicache_ratio,
                hicache_size=server_args.hicache_size,
                hicache_write_policy=server_args.hicache_write_policy,
                enable_kv_cache_events=self.enable_kv_cache_events,
            )
        # æ ‡å‡†Pythonå®ç°çš„RadixCache
        else:
            self.tree_cache = RadixCache(
                req_to_token_pool=self.req_to_token_pool,
                token_to_kv_pool_allocator=self.token_to_kv_pool_allocator,
                page_size=self.page_size,
                disable=False,
                enable_kv_cache_events=self.enable_kv_cache_events,
            )
```

---

## ğŸ”— ReqToTokenPool - è¯·æ±‚åˆ°Tokenæ˜ å°„æ± 

`ReqToTokenPool`è´Ÿè´£ç®¡ç†è¯·æ±‚IDåˆ°å…¶tokenä½ç½®çš„æ˜ å°„å…³ç³»ï¼š

```python
class ReqToTokenPool:
    """A memory pool that maps a request to its token locations."""

    def __init__(self, size: int, max_context_len: int, device: str, enable_memory_saver: bool):
        memory_saver_adapter = TorchMemorySaverAdapter.create(enable=enable_memory_saver)
        
        self.size = size
        self.max_context_len = max_context_len
        self.device = device
        
        # é¢„åˆ†é…å›ºå®šå¤§å°çš„äºŒç»´å¼ é‡å­˜å‚¨è¯·æ±‚çš„tokenä½ç½®
        with memory_saver_adapter.region(GPU_MEMORY_TYPE_KV_CACHE):
            self.req_to_token = torch.zeros(
                (size, max_context_len), dtype=torch.int32, device=device
            )
        
        # ä½¿ç”¨ç®€å•çš„åˆ—è¡¨ç®¡ç†å¯ç”¨æ§½ä½
        self.free_slots = list(range(size))

    def alloc(self, need_size: int) -> List[int]:
        """åˆ†é…æŒ‡å®šæ•°é‡çš„æ§½ä½"""
        if need_size > len(self.free_slots):
            return None
        
        select_index = self.free_slots[:need_size]
        self.free_slots = self.free_slots[need_size:]
        return select_index

    def free(self, free_index: Union[int, List[int]]):
        """é‡Šæ”¾æ§½ä½"""
        if isinstance(free_index, (int,)):
            self.free_slots.append(free_index)
        else:
            self.free_slots.extend(free_index)

    def available_size(self):
        """è¿”å›å¯ç”¨æ§½ä½æ•°é‡"""
        return len(self.free_slots)
        
    def write(self, indices, values):
        """å†™å…¥tokenä½ç½®æ˜ å°„"""
        self.req_to_token[indices] = values
        
    def clear(self):
        """æ¸…ç©ºæ‰€æœ‰åˆ†é…ï¼Œé‡ç½®ä¸ºåˆå§‹çŠ¶æ€"""
        self.free_slots = list(range(self.size))
```

## KVç¼“å­˜åˆ†é…å™¨

### BaseTokenToKVPoolAllocatoråŸºç±»

æ‰€æœ‰KVç¼“å­˜åˆ†é…å™¨çš„åŸºç±»ï¼Œå®šä¹‰äº†åŸºæœ¬çš„åˆ†é…æ¥å£ï¼š

```python
class BaseTokenToKVPoolAllocator(abc.ABC):
    def __init__(self, size: int, page_size: int, dtype: torch.dtype, 
                 device: str, kvcache: KVCache, need_sort: bool):
        self.size = size
        self.page_size = page_size
        self.dtype = dtype
        self.device = device
        self._kvcache = kvcache
        self.need_sort = need_sort

        self.free_pages = None
        self.release_pages = None
        self.is_not_in_free_group = True
        self.free_group = []

    def available_size(self):
        """è¿”å›å¯ç”¨çš„tokenæ•°é‡"""
        return (len(self.free_pages) + len(self.release_pages)) * self.page_size

    def backup_state(self):
        """å¤‡ä»½å½“å‰çŠ¶æ€"""
        return (self.free_pages, self.release_pages)

    def restore_state(self, state):
        """æ¢å¤çŠ¶æ€"""
        self.free_pages, self.release_pages = state
```

### TokenToKVPoolAllocatorå®ç°

æ ‡å‡†çš„tokenåˆ°KV poolåˆ†é…å™¨ï¼š

```python
class TokenToKVPoolAllocator(BaseTokenToKVPoolAllocator):
    """An allocator managing the indices to kv cache data."""

    def __init__(self, size: int, dtype: torch.dtype, device: str, 
                 kvcache: KVCache, need_sort: bool):
        super().__init__(size, 1, dtype, device, kvcache, need_sort)
        self.clear()

    def clear(self):
        """æ¸…ç©ºåˆ†é…å™¨ï¼Œé‡ç½®æ‰€æœ‰é¡µé¢ä¸ºå¯ç”¨çŠ¶æ€"""
        # é¡µé¢0ç”¨äºå¡«å……ï¼Œä»1å¼€å§‹åˆ†é…
        self.free_pages = torch.arange(
            1, self.size + 1, dtype=torch.int64, device=self.device
        )
        self.is_not_in_free_group = True
        self.free_group = []
        self.release_pages = torch.empty((0,), dtype=torch.int64, device=self.device)

    def alloc(self, need_size: int):
        """åˆ†é…æŒ‡å®šæ•°é‡çš„tokenæ§½ä½"""
        if self.need_sort and need_size > len(self.free_pages):
            self.merge_and_sort_free()

        if need_size > len(self.free_pages):
            return None

        select_index = self.free_pages[:need_size]
        self.free_pages = self.free_pages[need_size:]
        return select_index

    def free(self, free_index: torch.Tensor):
        """é‡Šæ”¾tokenæ§½ä½"""
        if free_index.numel() == 0:
            return

        if self.is_not_in_free_group:
            if self.need_sort:
                self.release_pages = torch.cat((self.release_pages, free_index))
            else:
                self.free_pages = torch.cat((self.free_pages, free_index))
        else:
            self.free_group.append(free_index)
```

## å‰ç¼€ç¼“å­˜ç³»ç»Ÿ

### RadixCacheå®ç°

æ ‡å‡†çš„å‰ç¼€ç¼“å­˜å®ç°ï¼ŒåŸºäºåŸºæ•°æ ‘æ•°æ®ç»“æ„ï¼š

```python
class RadixCache(BasePrefixCache):
    def __init__(self, req_to_token_pool: ReqToTokenPool,
                 token_to_kv_pool_allocator: BaseTokenToKVPoolAllocator,
                 page_size: int, disable: bool = False,
                 enable_kv_cache_events: bool = False):
        self.req_to_token_pool = req_to_token_pool
        self.token_to_kv_pool_allocator = token_to_kv_pool_allocator
        self.page_size = page_size
        self.disable = disable
        self.enable_kv_cache_events = enable_kv_cache_events
        self.kv_event_queue = []

        # æ ¹æ®page_sizeé€‰æ‹©åŒ¹é…å‡½æ•°
        if self.page_size == 1:
            self.key_match_fn = _key_match_page_size1
            self.get_child_key_fn = lambda key: key[0]
        else:
            self.key_match_fn = partial(_key_match_paged, page_size=page_size)
            self.get_child_key_fn = lambda key: tuple(key[:page_size])
        self.reset()

    def reset(self):
        """é‡ç½®ç¼“å­˜æ ‘"""
        self.root_node = TreeNode()
        self.root_node.key = []
        self.root_node.value = []
        self.root_node.lock_ref = 1
        self.evictable_size_ = 0
        self.protected_size_ = 0

    def match_prefix(self, key: List[int], **kwargs) -> MatchResult:
        """åŒ¹é…æœ€é•¿å…¬å…±å‰ç¼€"""
        # å®é™…çš„å‰ç¼€åŒ¹é…é€»è¾‘åœ¨è¿™é‡Œå®ç°
        pass
```

### ChunkCacheå®ç°

ç”¨äºåˆ†å—é¢„å¡«å……æ—¶çš„ç®€åŒ–ç¼“å­˜ï¼š

```python
class ChunkCache(BasePrefixCache):
    def __init__(self, req_to_token_pool: ReqToTokenPool,
                 token_to_kv_pool_allocator: BaseTokenToKVPoolAllocator,
                 page_size: int):
        self.req_to_token_pool = req_to_token_pool
        self.token_to_kv_pool_allocator = token_to_kv_pool_allocator
        self.page_size = page_size

    def match_prefix(self, **unused_kwargs) -> MatchResult:
        """ChunkCacheä¸æ‰§è¡Œå‰ç¼€åŒ¹é…ï¼Œæ€»æ˜¯è¿”å›ç©ºç»“æœ"""
        return MatchResult(
            device_indices=torch.empty((0,), dtype=torch.int64),
            last_device_node=None,
            last_host_node=None,
        )

    def cache_finished_req(self, req: Req):
        """ç¼“å­˜å·²å®Œæˆçš„è¯·æ±‚"""
        kv_indices = self.req_to_token_pool.req_to_token[
            req.req_pool_idx,
            : len(req.origin_input_ids) + max(len(req.output_ids) - 1, 0),
        ]
        self.req_to_token_pool.free(req.req_pool_idx)
        self.token_to_kv_pool_allocator.free(kv_indices)

    def cache_unfinished_req(self, req: Req):
        """ç¼“å­˜æœªå®Œæˆçš„è¯·æ±‚"""
        kv_indices = self.req_to_token_pool.req_to_token[
            req.req_pool_idx, : len(req.fill_ids)
        ]
        req.prefix_indices = kv_indices
```

## æ··åˆç¼“å­˜æ¶æ„

SGLangæ”¯æŒSWA (Sliding Window Attention) æ··åˆç¼“å­˜æ¶æ„ï¼Œå…è®¸æ¨¡å‹åŒæ—¶ä½¿ç”¨å…¨æ³¨æ„åŠ›å’Œæ»‘åŠ¨çª—å£æ³¨æ„åŠ›æœºåˆ¶ï¼š

### SWAæ··åˆç¼“å­˜åˆå§‹åŒ–

```python
def init_memory_pool_and_cache(self):
    """åˆå§‹åŒ–å†…å­˜æ± ï¼Œæ”¯æŒæ··åˆç¼“å­˜æ¨¡å¼"""
    server_args = self.server_args

    # ä»tensor parallel workerè·å–å†…å­˜æ± 
    self.req_to_token_pool, self.token_to_kv_pool_allocator = (
        self.tp_worker.get_memory_pool()
    )

    # æ£€æŸ¥æ˜¯å¦ä¸ºæ··åˆæ¨¡å¼
    self.is_hybrid = isinstance(
        self.token_to_kv_pool_allocator, SWATokenToKVPoolAllocator
    )

    # æ ¹æ®é…ç½®é€‰æ‹©ç¼“å­˜å®ç°
    if (server_args.chunked_prefill_size is not None 
        and server_args.disable_radix_cache):
        if self.is_hybrid:
            ChunkCacheClass = SWAChunkCache  # SWAåˆ†å—ç¼“å­˜
        else:
            ChunkCacheClass = ChunkCache     # æ ‡å‡†åˆ†å—ç¼“å­˜
        self.tree_cache = ChunkCacheClass(
            req_to_token_pool=self.req_to_token_pool,
            token_to_kv_pool_allocator=self.token_to_kv_pool_allocator,
            page_size=self.page_size,
        )
    else:
        if self.is_hybrid:
            self.tree_cache = SWARadixCache(  # SWAåŸºæ•°ç¼“å­˜
                req_to_token_pool=self.req_to_token_pool,
                token_to_kv_pool_allocator=self.token_to_kv_pool_allocator,
                page_size=self.page_size,
                disable=False,
            )
        else:
            self.tree_cache = RadixCache(     # æ ‡å‡†åŸºæ•°ç¼“å­˜
                req_to_token_pool=self.req_to_token_pool,
                token_to_kv_pool_allocator=self.token_to_kv_pool_allocator,
                page_size=self.page_size,
                disable=False,
            )
```

### SWA Tokenä¿¡æ¯è·å–

```python
def _get_swa_token_info(self):
    """è·å–SWAæ··åˆç¼“å­˜çš„tokenä½¿ç”¨ä¿¡æ¯"""
    full_available_size = self.token_to_kv_pool_allocator.full_available_size()
    full_evictable_size = self.tree_cache.full_evictable_size()
    swa_available_size = self.token_to_kv_pool_allocator.swa_available_size()
    swa_evictable_size = self.tree_cache.swa_evictable_size()
    
    full_num_used = self.full_tokens_per_layer - (full_available_size + full_evictable_size)
    swa_num_used = self.swa_tokens_per_layer - (swa_available_size + swa_evictable_size)
    
    full_token_usage = full_num_used / self.full_tokens_per_layer
    swa_token_usage = swa_num_used / self.swa_tokens_per_layer
    
    return (
        full_num_used, swa_num_used, full_token_usage, swa_token_usage,
        full_available_size, full_evictable_size, 
        swa_available_size, swa_evictable_size
    )
```

## å†…å­˜æ£€æŸ¥æœºåˆ¶

è°ƒåº¦å™¨æä¾›äº†å…¨é¢çš„å†…å­˜æ£€æŸ¥åŠŸèƒ½ï¼Œæ”¯æŒæ··åˆç¼“å­˜ï¼š

```python
def check_memory(self):
    """æ£€æŸ¥å†…å­˜æ³„æ¼å’ŒçŠ¶æ€ä¸€è‡´æ€§"""
    
    if self.is_hybrid:
        # æ··åˆç¼“å­˜çš„å†…å­˜æ£€æŸ¥
        (full_num_used, swa_num_used, _, _,
         full_available_size, full_evictable_size,
         swa_available_size, swa_evictable_size) = self._get_swa_token_info()
        
        memory_leak = full_num_used != 0 or swa_num_used != 0
        token_msg = (
            f"{self.full_tokens_per_layer=}, {full_available_size=}, {full_evictable_size=}, "
            f"{self.tree_cache.full_protected_size()=}\n"
            f"{self.swa_tokens_per_layer=}, {swa_available_size=}, {swa_evictable_size=}, "
            f"{self.tree_cache.swa_protected_size()=}\n"
        )
    else:
        # æ ‡å‡†ç¼“å­˜çš„å†…å­˜æ£€æŸ¥
        _, _, available_size, evictable_size = self._get_token_info()
        protected_size = self.tree_cache.protected_size()
        memory_leak = (available_size + evictable_size) != (
            self.max_total_num_tokens
            if not self.enable_hierarchical_cache
            else self.max_total_num_tokens - protected_size
        )
        token_msg = f"{self.max_total_num_tokens=}, {available_size=}, {evictable_size=}, {protected_size=}\n"
    
    # æ£€æµ‹åˆ°å†…å­˜æ³„æ¼æ—¶æŠ›å‡ºå¼‚å¸¸
    if memory_leak:
        msg = "token_to_kv_pool_allocator memory leak detected! " f"{token_msg}"
        raise ValueError(msg)
    
    # æ£€æŸ¥è¯·æ±‚æ± å†…å­˜æ³„æ¼
    if self.disaggregation_mode == DisaggregationMode.DECODE:
        req_total_size = (
            self.req_to_token_pool.size + self.req_to_token_pool.pre_alloc_size
        )
    else:
        req_total_size = self.req_to_token_pool.size
    
    if len(self.req_to_token_pool.free_slots) != req_total_size:
        msg = (
            "req_to_token_pool memory leak detected!"
            f"available_size={len(self.req_to_token_pool.free_slots)}, "
            f"total_size={self.req_to_token_pool.size}\n"
        )
        raise ValueError(msg)
```

## æ€»ç»“

SGLangçš„å†…å­˜ç®¡ç†ç³»ç»Ÿé€šè¿‡ä»¥ä¸‹å‡ ä¸ªæ ¸å¿ƒç»„ä»¶å®ç°ï¼š

1. **ReqToTokenPool**: ç®¡ç†è¯·æ±‚åˆ°tokenä½ç½®çš„æ˜ å°„
2. **TokenToKVPoolAllocator**: ç®¡ç†KVç¼“å­˜çš„åˆ†é…å’Œé‡Šæ”¾ï¼Œæ”¯æŒæ ‡å‡†å’ŒSWAæ··åˆæ¨¡å¼
3. **RadixCache/ChunkCache**: æä¾›å‰ç¼€ç¼“å­˜åŠŸèƒ½ï¼Œæ”¯æŒSWAæ··åˆç¼“å­˜æ¶æ„
4. **å…¨é¢çš„å†…å­˜æ£€æŸ¥**: ç›‘æ§å†…å­˜æ³„æ¼å’ŒçŠ¶æ€ä¸€è‡´æ€§ï¼Œæ”¯æŒæ··åˆç¼“å­˜æ¨¡å¼
5. **SWAæ··åˆç¼“å­˜**: æ”¯æŒæ»‘åŠ¨çª—å£æ³¨æ„åŠ›çš„æ··åˆç¼“å­˜æ¶æ„

è¿™ä¸ªè®¾è®¡æ—¢ä¿æŒäº†ç®€æ´æ€§å’Œå®ç”¨æ€§ï¼Œåˆæ”¯æŒäº†å…ˆè¿›çš„æ··åˆæ³¨æ„åŠ›æœºåˆ¶ï¼Œç¡®ä¿åœ¨ä¸åŒåœºæ™¯ä¸‹éƒ½èƒ½é«˜æ•ˆåˆ©ç”¨GPUå†…å­˜ã€‚