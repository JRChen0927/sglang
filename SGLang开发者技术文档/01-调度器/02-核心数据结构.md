# 核心数据结构

SGLang调度器的高效运行依赖于一系列精心设计的数据结构。这些数据结构不仅承载着请求的各种信息，还负责批次管理、内存分配和模型推理的协调。理解这些核心数据结构是深入掌握SGLang调度器工作原理的基础。

## 数据流转架构

SGLang采用分层的数据处理架构，请求从接收到执行经历了三个主要的数据结构层次：

**调度器层面的ScheduleBatch**负责存储调度器需要的所有信息，包括请求列表、内存池引用、缓存管理等高层调度决策所需的数据。

**模型工作器层面的ModelWorkerBatch**是ScheduleBatch的简化版本，只包含模型前向推理所需的核心数据，去除了调度器特有的管理信息。

**模型执行器层面的ForwardBatch**包含最底层的GPU张量数据，是实际在GPU上执行计算时使用的数据格式。

这种分层设计确保了每个组件只处理与其职责相关的数据，提高了系统的模块化程度和执行效率。

## Req类详解

Req类是SGLang中表示单个请求的核心数据结构，包含了请求从创建到完成的全部信息。

### 基本属性

Req类的构造函数定义了请求的基本属性：

```python
def __init__(self, rid: str, origin_input_text: str, origin_input_ids: List[int],
             sampling_params: SamplingParams, return_logprob: bool = False,
             top_logprobs_num: int = 0, stream: bool = False):
    self.rid = rid                          # 请求唯一标识符
    self.origin_input_text = origin_input_text    # 原始输入文本
    self.origin_input_ids = origin_input_ids      # 原始输入token序列
    self.sampling_params = sampling_params        # 采样参数配置
    self.return_logprob = return_logprob         # 是否返回对数概率
    self.stream = stream                        # 是否启用流式输出
```

这些基本属性定义了请求的核心信息和处理方式。请求ID用于在整个系统中唯一标识这个请求，原始输入信息记录了用户的输入内容，采样参数控制了生成的行为，而各种标志位则决定了请求的处理模式。

### 状态管理

Req类维护着请求在处理过程中的各种状态信息：

**输出管理**  
output_ids列表记录了模型生成的所有token，fill_ids是origin_input_ids和output_ids的组合，表示当前的完整token序列。

**生成控制**  
finished_reason记录请求完成的原因，可能是达到最大长度、遇到停止token或其他条件。各种长度限制和控制参数确保生成过程按预期进行。

**内存映射**  
req_pool_indices和其他索引信息维护着请求在各种内存池中的位置，这对于内存管理和缓存机制至关重要。

### 多模态支持

Req类还支持多模态输入，包括图像、音频等非文本数据：

```python
self.input_embeds = input_embeds            # 输入嵌入向量
self.image_inputs = None                    # 图像输入数据
self.multimodal_inputs = None              # 多模态输入统一接口
```

这种设计使得SGLang能够处理不仅仅是文本的多种模态输入，为多模态大语言模型提供了基础支持。

## ScheduleBatch类详解

ScheduleBatch是调度器层面的核心数据结构，负责管理一个批次中所有请求的信息和资源。

### 请求和资源管理

ScheduleBatch通过dataclass装饰器定义了清晰的数据结构：

```python
@dataclasses.dataclass
class ScheduleBatch(ScheduleBatchDisaggregationDecodeMixin):
    # Request, memory pool, and cache
    reqs: List[Req]                                          # 批次中的请求列表
    req_to_token_pool: ReqToTokenPool = None                # 请求到token池的映射
    token_to_kv_pool_allocator: BaseTokenToKVPoolAllocator = None  # KV缓存分配器
    tree_cache: BasePrefixCache = None                      # 前缀缓存树
```

这些字段定义了批次的基本组成和资源依赖。请求列表是批次的核心内容，而各种池和缓存的引用则确保了批次能够正确访问和管理系统资源。

### 批次配置

ScheduleBatch还包含了批次处理的各种配置信息：

```python
# Batch configs
model_config: ModelConfig = None           # 模型配置信息
forward_mode: ForwardMode = None           # 前向模式（预填充或解码）
enable_overlap: bool = False               # 是否启用重叠处理
batch_is_full: bool = False               # 批次是否已满的标志
```

这些配置信息指导着批次的处理方式。forward_mode决定了批次是进行预填充还是解码处理，enable_overlap控制是否启用CPU-GPU重叠优化，batch_is_full标志则用于优化调度决策。

### 模型执行数据

ScheduleBatch还包含了传递给模型执行器的批量化数据：

```python
# Batched arguments to model runner
input_ids: torch.Tensor = None            # 输入token ID张量
seq_lens: torch.Tensor = None             # 序列长度张量
req_pool_indices: torch.Tensor = None     # 请求池索引张量
out_cache_loc: torch.Tensor = None        # 输出缓存位置张量
```

这些张量化的数据是GPU计算的直接输入，将批次中所有请求的相关信息组织成了适合并行处理的格式。

### 采样和生成信息

```python
# Sampling info
sampling_info: SamplingBatchInfo = None           # 当前批次采样信息
next_batch_sampling_info: SamplingBatchInfo = None # 下一批次采样信息
```

采样信息管理着批次中所有请求的采样参数，确保每个请求都能按照指定的方式进行文本生成。

## ModelWorkerBatch数据结构

ModelWorkerBatch是ScheduleBatch向模型工作器传递的简化版本，去除了调度器特有的管理信息，专注于模型推理所需的核心数据：

```python
@dataclasses.dataclass
class ModelWorkerBatch:
    bid: int                               # 批次ID
    forward_mode: ForwardMode              # 前向模式
    input_ids: torch.Tensor               # 输入token张量
    req_pool_indices: torch.Tensor        # 请求池索引
    seq_lens: torch.Tensor                # 序列长度
    out_cache_loc: torch.Tensor           # 输出缓存位置
    sampling_info: SamplingBatchInfo      # 采样信息
```

这种简化确保了模型工作器只需要关注推理相关的信息，提高了数据传递的效率。

## 内存管理数据结构

### ReqToTokenPool

ReqToTokenPool管理着请求到token位置的映射关系，是内存管理的重要组成部分。它维护着每个请求在内存中的token位置信息，支持动态的内存分配和回收。

### BaseTokenToKVPoolAllocator

这个抽象基类定义了KV缓存分配器的接口，具体的实现类负责管理KV缓存的分配、回收和优化。不同的实现可以采用不同的分配策略，如页面分配、连续分配等。

### BasePrefixCache

前缀缓存是SGLang的重要优化特性，BasePrefixCache定义了前缀缓存的通用接口。具体的实现如RadixCache能够识别和复用请求间的公共前缀，显著减少计算开销。

## 多模态数据结构

SGLang支持多模态输入，相关的数据结构包括：

### MultimodalInputs

这个类统一管理各种模态的输入数据，包括图像的pixel_values、音频的audio_values等。通过统一的接口，不同模态的数据能够被一致地处理和传递。

### MultimodalDataItem

表示单个多模态数据项，包含了数据类型、内容和相关的元数据信息。

## 数据结构协作关系

这些数据结构之间存在着复杂的协作关系。Req对象是最基本的数据单元，ScheduleBatch将多个Req组织成批次，同时管理着各种资源池的引用。在处理过程中，ScheduleBatch会转换成ModelWorkerBatch传递给下游组件，最终转换成ForwardBatch在GPU上执行。

内存管理相关的数据结构为这个过程提供支撑，确保每个请求都能获得必要的内存资源，同时通过缓存机制优化性能。多模态数据结构则扩展了系统的输入能力，使得SGLang能够处理不仅仅是文本的多种类型输入。

## 数据结构的设计优势

SGLang的数据结构设计体现了几个重要的设计原则：

**分层抽象**通过不同层次的数据结构，系统能够在不同的抽象层面进行优化，调度器关注高层决策，模型执行器关注底层计算。

**模块化设计**各个数据结构职责清晰，相互之间通过明确的接口进行交互，提高了系统的可维护性。

**性能优化**数据结构的设计充分考虑了性能因素，如批量化处理、内存局部性、缓存友好等。

**扩展性**通过抽象基类和mixin模式，数据结构具备良好的扩展性，能够支持新功能的添加和现有功能的优化。

理解这些核心数据结构及其相互关系，是深入掌握SGLang调度器工作机制的关键。这些数据结构不仅承载着系统的核心信息，还体现了SGLang在性能、可维护性和扩展性方面的设计考量。
